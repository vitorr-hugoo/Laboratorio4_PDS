# -*- coding: utf-8 -*-
"""lab4_PDS_pt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Lgu5txzIjJUGuSnNbgfMYUzsMKc-paNE
"""

import numpy as np
import matplotlib.pyplot as plt

# Criar um sinal de exemplo
fs = 1000  # Frequência de amostragem em Hz
t = np.arange(0, 1/10, 1/fs)  # Vetor de tempo de 1 segundo
f1 = 50  # Frequência do sinal em Hz
#signal = np.sin(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz
signal = np.cos(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz

# Calcular a FFT
fft_result = np.fft.fft(signal)
freqs = np.fft.fftfreq(len(fft_result), 1/fs)

# Plotar o sinal no domínio do tempo
plt.subplot(2, 1, 1)
plt.plot(t, signal)
plt.title('Sinal no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

# Plotar a FFT no domínio da frequência
plt.subplot(2, 1, 2)
plt.plot(freqs, np.abs(fft_result))
plt.title('FFT - Domínio da Frequência')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude espectral')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Criar um sinal de exemplo
fs = 1000  # Frequência de amostragem em Hz
t = np.arange(0, 1/10, 1/fs)  # Vetor de tempo de 1 segundo
f1 = 50  # Frequência do sinal em Hz
#signal = np.sin(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz
signal = np.cos(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz

# Calcular a FFT
fft_result = np.fft.fft(signal)

# Calcular a IFFT
ifft_result = np.fft.ifft(fft_result)

# Plotar o sinal original no domínio do tempo
plt.subplot(3, 1, 1)
plt.plot(t, signal)
plt.title('Sinal Original no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

# Plotar a FFT no domínio da frequência
plt.subplot(3, 1, 2)
plt.plot(np.fft.fftfreq(len(fft_result), 1/fs), np.abs(fft_result))
plt.title('FFT - Domínio da Frequência')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude espectral')

# Plotar o sinal reconstruído usando IFFT no domínio do tempo
plt.subplot(3, 1, 3)
plt.plot(t, ifft_result)
plt.title('Sinal Reconstruído com IFFT no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import time

# Criar um sinal de exemplo
fs = 1000  # Frequência de amostragem em Hz
t = np.arange(0, 1/10, 1/fs)  # Vetor de tempo de 1 segundo
f1 = 50  # Frequência do sinal em Hz
signal = np.cos(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz

# Medir o tempo para a FFT
start_time_fft = time.time()
fft_result = np.fft.fft(signal)
end_time_fft = time.time()
time_fft = end_time_fft - start_time_fft

# Medir o tempo para a IFFT
start_time_ifft = time.time()
ifft_result = np.fft.ifft(fft_result)
end_time_ifft = time.time()
time_ifft = end_time_ifft - start_time_ifft

# Plotar o sinal original no domínio do tempo
plt.subplot(3, 1, 1)
plt.plot(t, signal)
plt.title('Sinal Original no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

# Plotar a FFT no domínio da frequência
plt.subplot(3, 1, 2)
plt.plot(np.fft.fftfreq(len(fft_result), 1/fs), np.abs(fft_result))
plt.title('FFT - Domínio da Frequência')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude espectral')

# Plotar o sinal reconstruído usando IFFT no domínio do tempo
plt.subplot(3, 1, 3)
plt.plot(t, ifft_result)
plt.title('Sinal Reconstruído com IFFT no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

plt.tight_layout()
plt.show()

# Exibir tempos de execução
print(f'Tempo para FFT: {(time_fft*1000):.6f} segundos')
print(f'Tempo para IFFT: {(time_ifft*1000):.6f} segundos')

import numpy as np
import matplotlib.pyplot as plt
import time

# Criar um sinal de exemplo
fs = 1000  # Frequência de amostragem em Hz
t = np.arange(0, 1, 1/fs)  # Vetor de tempo de 1 segundo
f1 = 5  # Frequência do sinal em Hz
signal = np.sin(2 * np.pi * f1 * t)  # Sinal senoidal de 5 Hz

# Calcular a FFT
fft_result = np.fft.fft(signal)
freqs = np.fft.fftfreq(len(fft_result), 1/fs)

# Definir uma frequência de corte para o filtro (remover frequências abaixo dessa)
frequencia_de_corte = 10  # Ajuste conforme necessário

# Aplicar o filtro zerando as frequências abaixo da frequência de corte
fft_result_filtrado = fft_result.copy()
fft_result_filtrado[np.abs(freqs) < frequencia_de_corte] = 0

# Calcular a IFFT para obter o sinal filtrado no domínio do tempo
sinal_filtrado = np.fft.ifft(fft_result_filtrado)

# Plotar o sinal original no domínio do tempo
plt.subplot(3, 1, 1)
plt.plot(t, signal, marker='o', linestyle='-', color='b')
plt.title('Sinal Original no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')

# Plotar a FFT do sinal original
plt.subplot(3, 1, 2)
plt.stem(freqs, np.abs(fft_result), basefmt='b', )
plt.title('FFT - Domínio da Frequência (Original)')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude espectral')

# Plotar a FFT do sinal filtrado
plt.subplot(3, 1, 3)
plt.stem(freqs, np.abs(fft_result_filtrado), basefmt='b', use_line_collection=True)
plt.title('FFT - Domínio da Frequência (Filtrado)')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude espectral')

plt.tight_layout()
plt.show()

# Plotar o sinal filtrado no domínio do tempo
plt.figure()
plt.plot(t, sinal_filtrado, marker='o', linestyle='-', color='r')
plt.title('Sinal Filtrado no Domínio do Tempo')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')
plt.show()